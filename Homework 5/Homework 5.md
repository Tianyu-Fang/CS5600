# Evaluation of 3 Free Space Management Policies
## Result
```
--- Results ---
Memory Used: 50%
Free Memory: 30
Largest Free Block: 15
Total Allocations: 3
Total Deallocation: 1
Allocation Failures: 0
```
**First Fit**: Fast and efficient for quickly finding an allocation, but can result in fragmentation at the start of the list.

**Best Fit**: Minimizes wasted space and small leftover fragments, but can leave smaller blocks that may not be useful for larger allocations and requires more time to scan the list.

**Worst Fit**: Leaves larger blocks intact, which can be helpful for future larger allocations but tends to waste memory by selecting overly large blocks and increasing fragmentation in some cases.


# Homework 5
## Chapter 15
1. Run with seeds 1, 2, and 3, and compute whether each virtual address generated by the process is in or out of bounds. If in bounds, compute the translation.

    ```
    $ ./relocation.py -s 1 -c
    $ ./relocation.py -s 2 -c
    $ ./relocation.py -s 3 -c
    ```

2. Run with these flags: `-s 0 -n 10`. What value do you have set `-l` (the bounds register) to in order to ensure that all the generated virtual addresses are within bounds?

    ```
    $ ./relocation.py -s 0 -n 10 -l 930 -c
    ```

3. Run with these flags: `-s 1 -n 10 -l 100`. What is the maximum value that base can be set to, such that the address space still fits into physical memory in its entirety?

    16 * 1024 - 100 = 16284

    ```
    $ ./relocation.py -s 1 -n 10 -l 100 -b 16284 -c
    ```

4. Run some of the same problems above, but with larger address spaces (`-a`) and physical memories (`-p`).

    1 * 1024 * 1024 * 1024 - 100 = 1073741724

    ```
    $ ./relocation.py -s 1 -n 10 -l 100 -b 1073741724 -a 32m -p 1g -c
    ```

## Chapter 16
1. First let’s use a tiny address space to translate some addresses. Here’s a simple set of parameters with a few different random seeds; can you translate the addresses?

    ```
    segmentation.py -a 128 -p 512 -b 0 -l 20 -B 512 -L 20 -s 0
    segmentation.py -a 128 -p 512 -b 0 -l 20 -B 512 -L 20 -s 1
    segmentation.py -a 128 -p 512 -b 0 -l 20 -B 512 -L 20 -s 2
    ```

2. Now, let’s see if we understand this tiny address space we’ve constructed (using the parameters from the question above). What is the highest legal virtual address in segment 0? What about the lowest legal virtual address in segment 1? What are the lowest and highest *illegal* addresses in this entire address space? Finally, how would you run `segmentation.py` with the `-A` flag to test if you are right?

    The highest legal virtual address in segment 0: 19

    The lowest legal virtual address in segment 1: 128 - 20 = 108

    Segment 0 physical addresses: 0-19

    Segment 1 physical addresses: 492-511

    The lowest illegal physical address: 20

    The highest illegal physical address: 491

    ```
    $ ./segmentation.py -a 128 -p 512 -b 0 -l 20 -B 512 -L 20 -s 1 -A 19,108,20,107 -c
    ```

3. Let’s say we have a tiny 16-byte address space in a 128-byte physical memory. What base and bounds would you set up so as to get the simulator to generate the following translation results for the specified address stream: valid, valid, violation, ..., violation, valid, valid? Assume the following parameters:

    ```
    segmentation.py -a 16 -p 128
        -A 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15
        --b0 ? --l0 ? --b1 ? --l1 ?
    ```

    ```
    $ ./segmentation.py -a 16 -p 128 -A 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 --b0 0 --l0 2 --b1 16 --l1 2 -c
    ```

4. Assume we want to generate a problem where roughly 90% of the randomly-generated virtual addresses are valid (not segmentation violations). How should you configure the simulator to do so? Which parameters are important to getting this outcome?

    -l = 0.9 * -a

5. Can you run the simulator such that no virtual addresses are valid? How?

    ```
    -l 0 -L 0
    ```
## Chapter 17
1. First run with the flags `-n 10 -H 0 -p BEST -s 0` to generate a few random allocations and frees. Can you predict what alloc()/free() will return? Can you guess the state of the free list after each request? What do you notice about the free list over time?

    The memory is chopped up into pieces.

2. How are the results different when using a WORST fit policy to search the freelist(`-p WORST`)? What changes?

    The memory is deviled to more pieces, and searched more elements.

3. What about when using FIRST fit `(-p FIRST`)? What speeds up when you use first fit?

    Searched less elements.

4. For the above questions, how the list is kept ordered can affect the time it takes to find a free location for some of the policies. Use the different free list orderings(`-l ADDRSORT,-l SIZESORT+,-l SIZESORT-`) to see how the policies and the list orderings interact.

    ```
    $ ./malloc.py -p BEST -l SIZESORT+ -c
    $ ./malloc.py -p FIRST -l SIZESORT+ -c
    $ ./malloc.py -p WORST -l SIZESORT- -c
    ```
5. Coalescing of a free list can be quite important. Increase the number of random allocations (say to -n 1000). What happens to larger allocation requests over time? Run with and without coalescing (i.e., without and with the -C flag). What differences in outcome do you see? How big is the free list over time in each case? Does the ordering of the list matter in this case?

    ```
    $ ./malloc.py -n 1000 -r 30 -c
    $ ./malloc.py -n 1000 -r 30 -c -C
    ```

    Without coalescing, larger allocation requests will return NULL and the free list's size is bigger.

    Sort by address is better.

6. What happens when you change the percent allocated fraction `-P` to higher than 50? What happens to allocations as it nears 100? What about as the percent nears 0?

    ```
    $ ./malloc.py -c -n 1000 -P 100
    $ ./malloc.py -c -n 1000 -P 1
    ```

    No more spaces to allocate. All pointers are freed.

7. What kind of specific requests can you make to generate a highly-fragmented free space? Use the -A flag to create fragmented free lists, and see how different policies and options change the organization of the free list.

    ```
    $ ./malloc.py -c -A +20,+20,+20,+20,+20,-0,-1,-2,-3,-4
    $ ./malloc.py -c -A +20,+20,+20,+20,+20,-0,-1,-2,-3,-4 -C
    $ ./malloc.py -c -A +10,-0,+20,-1,+30,-2,+40,-3 -l SIZESORT-
    $ ./malloc.py -c -A +10,-0,+20,-1,+30,-2,+40,-3 -l SIZESORT- -C
    $ ./malloc.py -c -A +10,-0,+20,-1,+30,-2,+40,-3 -p FIRST -l SIZESORT+
    $ ./malloc.py -c -A +10,-0,+20,-1,+30,-2,+40,-3 -p FIRST -l SIZESORT+ -C
    $ ./malloc.py -c -A +10,-0,+20,-1,+30,-2,+40,-3 -p FIRST -l SIZESORT-
    $ ./malloc.py -c -A +10,-0,+20,-1,+30,-2,+40,-3 -p FIRST -l SIZESORT- -C
    $ ./malloc.py -c -A +10,-0,+20,-1,+30,-2,+40,-3 -p WORST -l SIZESORT+
    $ ./malloc.py -c -A +10,-0,+20,-1,+30,-2,+40,-3 -p WORST -l SIZESORT+ -C
    $ ./malloc.py -c -A +10,-0,+20,-1,+30,-2,+40,-3 -p WORST -l SIZESORT-
    $ ./malloc.py -c -A +10,-0,+20,-1,+30,-2,+40,-3 -p WORST -l SIZESORT- -C
    ```
